<html><head></head><body><h2>Pencil markings: clearing used values from unsolved squares</h2>

<p>In this step you will continue calculating pencil marks for a single
group by implement the function <code>clear_used</code> in the file
<code>pencil_marks.s</code>:</p>

<pre><code>clear_used(board, group, used) -&gt;
    0: no changes
    1: something changed
</code></pre>

<p>where <code>board</code> and <code>group</code> are the same as in <code>get_used</code> and <code>used</code>
is a set of values used in solved squares (the same value returned
by <code>get_used</code>).</p>

<p>Here is an example input row with the same solved squares as before:</p>

<pre><code>+-----------------------+-----------------------+-----------------------+
|       | 1 2 3 | 1 2 3 | 1 2 3 |       | 1 2 3 |       | 1 2 3 |       |
|   1     4 5 6   4 5 6 | 4 5 6     3     4 5 6 |   5     4 5 6     6   |
|       | 7 8 9 | 7 8 9 | 7 8 9 |       | 7 8 9 |       | 7 8 9 |       |
| - - - + - - - + - - - | - - - + - - - + - - - | - - - + - - - + - - - |
</code></pre>

<p>If <code>clear_used</code> is called with the used set represented by</p>

<ul>
<li>0b0000000001101010 = 0x006a</li>
</ul>

<p>where the bit positions 1, 3, 5, and 6 are all ones and all other
positions are zeros and all unsolved positions have a full set of
pencil marks (as illustrated above), <code>clear_used</code> should change the
pencil marks in the row to be:</p>

<pre><code>+-----------------------+-----------------------+-----------------------+
|       | . 2 . | . 2 . | . 2 . |       | . 2 . |       | . 2 . |       |
|   1     4 . .   4 . . | 4 . .     3     4 . . |   5     4 . .     6   |
|       | 7 8 9 | 7 8 9 | 7 8 9 |       | 7 8 9 |       | 7 8 9 |       |
| - - - + - - - + - - - | - - - + - - - + - - - | - - - + - - - + - - - |
</code></pre>

<p>i.e., the values 1, 3, 5, and 6 have been “crossed off” the pencil
marks of all unsolved squares in the same group (row, column, or
box).</p>

<p>To clear some elements from a set we use <em>set difference</em>, normally
written as S-T, where the result is all elements in set S that are
not also in set T. S-T is equivalent to <code>S&amp;(~T)</code>, i.e., S
intersected with the complement of T. Flipping the bits of <code>used</code>
(using the <code>not</code> instruction) will give us the complement of the set
it represents.</p>

<p>At a high level, this function will:</p>

<ul>
<li>Loop over the nine positions of the group</li>
<li>For each square, count the set bits in positions 1–9</li>
<li>If the count is <em>not</em> 1, this represents an unsolved square so
cross off all the elements from the <code>used</code> list</li>
<li>Note if anything actually changed and return true if so</li>
</ul>

<p>The following pseudo-code is a starting point for implementing
<code>clear_used</code>:</p>

<pre><code>clear_used(board, group, used) -&gt; 0 or 1:
    notused = ~used (flip the bits)
    change_made = 0
    for group_index = 0; group_index &lt; 9; group_index++
        board_index = group[group_index]
        elt = board[board_index] # remember the address

        count = count_bits(elt)

        if count != 1 (indicating an unsolved square):
            new_elt = elt &amp; notused (clear the bits indicated by used)
            if new_elt != elt:
                board[board_index] = new_elt # use the address from earlier
                change_made = 1

    return change_made
</code></pre>

<p>Note that this is a non-leaf function.</p>
</body></html>